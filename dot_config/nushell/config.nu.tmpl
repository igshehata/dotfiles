# config.nu
#
# Installed by:
# version = "0.106.1"
#
# This file is used to override default Nushell settings, define
# (or import) custom commands, or run any other startup tasks.
# See https://www.nushell.sh/book/configuration.html
#
# Nushell sets "sensible defaults" for most configuration settings, 
# so your `config.nu` only needs to override these defaults if desired.
#
# You can open this file in your default editor using:
#     config nu
#
# You can also pretty-print and page through the documentation for configuration
# options using:
#     config nu --doc | nu-highlight | less -R
$env.config.edit_mode = 'vi'

def "parse vars" [] {
  $in | from csv --noheaders --no-infer | rename 'op' 'name' 'value'
}

def --env "update-env" [] {
  for $var in $in {
    if $var.op == "set" {
      if ($var.name | str upcase) == 'PATH' {
        $env.PATH = ($var.value | split row (char esep))
      } else {
        load-env {($var.name): $var.value}
      }
    } else if $var.op == "hide" and $var.name in $env {
      hide-env $var.name
    }
  }
}

def --env add-hook [field: cell-path new_hook: any] {
  let field = $field | split cell-path | update optional true | into cell-path
  let old_config = $env.config? | default {}
  let old_hooks = $old_config | get $field | default []
  $env.config = ($old_config | upsert $field ($old_hooks ++ [$new_hook]))
}

def --env mise_hook [] {
  ^mise hook-env -s nu
    | parse vars
    | update-env
}

def --env --wrapped mise [command?: string, --help, ...rest: string] {
  let commands = ["deactivate", "shell", "sh"]

  if ($command == null) {
    ^mise
  } else if ($command == "activate") {
    $env.MISE_SHELL = "nu"
  } else if ($command in $commands) {
    ^mise $command ...$rest
      | parse vars
      | update-env
  } else {
    ^mise $command ...$rest
  }
}

$env.MISE_SHELL = "nu"
let mise_hook = {
  condition: { "MISE_SHELL" in $env }
  code: { mise_hook }
}
add-hook hooks.pre_prompt $mise_hook
add-hook hooks.env_change.PWD $mise_hook

# Transient prompt configuration
$env.TRANSIENT_PROMPT_COMMAND = {|| starship module character }
$env.TRANSIENT_PROMPT_COMMAND_RIGHT = {|| starship module time }

# Atuin is initialized from Nu vendor autoload scripts generated in env.nu

# ============================================================================
# Git Aliases (from nu_scripts)
# ============================================================================
use ~/.config/nushell/git-aliases.nu *

# Git push: "git push<Tab>" completes to "origin <current-branch>"
$env.config.completions.external.completer = {|spans|
    if ($spans | length) >= 2 and $spans.0 == "git" and $spans.1 == "push" {
        let branch = (do { ^git branch --show-current } | complete)
        if $branch.exit_code == 0 {
            let b = ($branch.stdout | str trim)
            [{value: $"origin ($b)", description: "push current branch"}]
        } else {
            null
        }
    } else {
        # Fall back to carapace for everything else
        carapace $spans.0 nushell ...$spans | from json
    }
}

# ============================================================================
# Aliases
# ============================================================================
alias ci = code-insiders
alias ?? = aichat
alias lt = eza -T --no-permissions --icons --level=2 --git
alias llt = eza -lT --no-permissions --icons --level=2 --git
alias py = python3
alias pip = pip3
alias nv = nvim
# Nix darwin (requires sudo since May 2025 - Phase 1 of multi-user support)
alias drs = sudo darwin-rebuild switch --flake ~/nix-config#{{ .chezmoi.hostname }}
# ============================================================================
# Television (tv) - Smart Autocomplete with Fuzzy Finding
# Ctrl+T: Fuzzy find files, directories, and commands
# Note: Ctrl+R remains with atuin for shell history
# ============================================================================

def tv_smart_autocomplete [] {
    let line = (commandline)
    let cursor = (commandline get-cursor)
    let lhs = ($line | str substring 0..$cursor)
    let rhs = ($line | str substring $cursor..)
    let output = (tv --inline --autocomplete-prompt $lhs | str trim)

    if ($output | str length) > 0 {
        let needs_space = not ($lhs | str ends-with " ")
        let lhs_with_space = if $needs_space { $"($lhs) " } else { $lhs }
        let new_line = $lhs_with_space + $output + $rhs
        let new_cursor = ($lhs_with_space + $output | str length)
        commandline edit --replace $new_line
        commandline set-cursor $new_cursor
    }
}

# Bind Ctrl+T for TV smart autocomplete
$env.config = (
  $env.config
  | upsert keybindings (
      $env.config.keybindings
      | append [
          {
              name: tv_completion,
              modifier: Control,
              keycode: char_t,
              mode: [vi_normal, vi_insert, emacs],
              event: {
                  send: executehostcommand,
                  cmd: "tv_smart_autocomplete"
              }
          }
          # Option+Backspace: delete word backward
          {
              name: backward_delete_word,
              modifier: Alt,
              keycode: Backspace,
              mode: [vi_normal, vi_insert, emacs],
              event: { edit: BackspaceWord }
          }
          # Command+Backspace: delete to start of line
          {
              name: delete_to_line_start,
              modifier: Super,
              keycode: Backspace,
              mode: [vi_normal, vi_insert, emacs],
              event: { edit: CutFromLineStart }
          }
      ]
  )
)

# ============================================================================
# Nix Helpers
# ============================================================================

# nix add [--brew|--cask] <packages...> - Add packages to nix configuration
def "nix add" [
    --brew    # Add to Homebrew brews instead of nix packages
    --cask    # Add to Homebrew casks instead of nix packages
    ...packages: string
] {
    if ($packages | is-empty) {
        print "Usage: nix add [--brew|--cask] <package1> [package2] ..."
        print "  (default)  Add to nix packages"
        print "  --brew     Add to Homebrew brews"
        print "  --cask     Add to Homebrew casks"
        return
    }

    let config_file = $"($env.HOME)/nix-config/configuration.nix"

    for pkg in $packages {
        if $cask {
            ^sed -i '' $"/casks = \\[/a\\\n      \"($pkg)\"" $config_file
            print $"Added ($pkg) to casks"
        } else if $brew {
            ^sed -i '' $"/brews = \\[/a\\\n      \"($pkg)\"" $config_file
            print $"Added ($pkg) to brews"
        } else {
            ^sed -i '' $"/environment.systemPackages = with pkgs; \\[/a\\\n    ($pkg)" $config_file
            print $"Added ($pkg) to nix packages"
        }
    }

    print ""
    print "Next: drs; chezmoi re-add ~/nix-config/configuration.nix"
}

# nix dedupe - Remove brews that exist in nix packages
def "nix dedupe" [] {
    let config_file = $"($env.HOME)/nix-config/configuration.nix"
    let content = open $config_file

    # Extract nix packages
    let nix_pkgs = ($content
        | parse --regex '(?s)environment\.systemPackages = with pkgs; \[([^\]]+)\]'
        | get capture0
        | first
        | split row "\n"
        | each { str trim }
        | where { $in != "" and not ($in | str starts-with "#") }
    )

    # Extract brews
    let brews = ($content
        | parse --regex '(?s)brews = \[([^\]]+)\]'
        | get capture0
        | first
        | split row "\n"
        | each { str trim | str replace -a '"' '' }
        | where { $in != "" and not ($in | str starts-with "#") }
    )

    mut found = 0
    for pkg in $nix_pkgs {
        if $pkg in $brews {
            ^sed -i '' $"/brews = \\[/,/\\];/{ /\"($pkg)\"/d; }" $config_file
            print $"Removed '($pkg)' from brews \(exists in nix packages\)"
            $found = $found + 1
        }
    }

    if $found == 0 {
        print "No duplicates found"
    } else {
        print ""
        print $"Removed ($found) duplicate\(s\)"
        print "Next: drs; chezmoi re-add ~/nix-config/configuration.nix"
    }
}
